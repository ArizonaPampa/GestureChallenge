package PlayerInterface;

import org.jbox2d.collision.FilterData;
import org.jbox2d.common.Vec2;
import org.mt4j.components.TransformSpace;
import org.mt4j.components.visibleComponents.widgets.MTTextField;
import org.mt4j.input.inputProcessors.IGestureEventListener;
import org.mt4j.input.inputProcessors.MTGestureEvent;
import org.mt4j.input.inputProcessors.componentProcessors.tapProcessor.TapEvent;
import org.mt4j.input.inputProcessors.componentProcessors.tapProcessor.TapProcessor;
import org.mt4j.util.MTColor;
import org.mt4j.util.font.FontManager;
import org.mt4j.util.math.Vector3D;

import physicsShapes.PhysicsShield;

import GameModel.Constants;
import GestureChallengeScene.GestureChallengeScene;

public class PlayerInterface {

	MTColor myColor;
	int myNumber;
	GestureChallengeScene myGCS;
	PlayerGoal myPG;
	PhysicsShield myPS;
	float angle;
	int playerNumber;
	int myCollisionID;
	
	
	
	public MTColor getMyColor() {
		return myColor;
	}



	public int getMyCollisionID() {
		return myCollisionID;
	}



	public PlayerInterface(MTColor color, int playerID,float angle,GestureChallengeScene gCS,int playerNumber){
		
		//init
		myColor=color;
		myNumber=playerID;
		myGCS = gCS;
		this.playerNumber = playerNumber;
		
		//creation goals
		//System.out.println("angle = "+angle);
		float x = myGCS.getMTApplication().width/2f +(float) (Math.cos(angle)*Constants.radiusCenterGoals);
		float y = myGCS.getMTApplication().height/2f +(float) (Math.sin(angle)*Constants.radiusCenterGoals);
		myPG=new PlayerGoal(myGCS.getMTApplication(), new Vector3D(x,y), myGCS.getWorld(), myGCS.getScale(), myColor,this.myNumber+1);
		myGCS.getPhysicsContainer().addChild(myPG);
		//MTTextField jdisp = new MTTextField(myPG.getCenterPointGlobal().x,myPG.getCenterPointGlobal().y,25f,25f,FontManager.DEFAULT_FONT,gCS.getMTApplication());
		//creation shields
		x = x -(float) (Math.cos(angle)*Constants.shieldDistance);
		y = y -(float) (Math.sin(angle)*Constants.shieldDistance);
		float coveredAngle = (float) Math.toRadians(180/(float)playerNumber);
		System.out.println(playerNumber);
		System.out.println("deg : "+String.valueOf(180/((float)playerNumber)));
		System.out.println("rad :"+coveredAngle);
		myPS=new PhysicsShield(Constants.shieldBigRadius,Constants.shieldSmallRadius,Constants.shieldSmallDef,Constants.shieldBigDef,coveredAngle,new Vector3D(x,y),myGCS.getMTApplication(),myGCS.getWorld(),0f,0f,0f,myGCS.getScale(),color);
		myGCS.getPhysicsContainer().addChild(myPS);
		System.out.println("Order: "+String.valueOf((float) Math.toDegrees(angle)+90));
		//myPS.setCenterRotation((float) (angle+Math.PI/2f));
		myPS.getBody().setXForm(
				myPS.getBody().getPosition(), (float) (angle+Math.PI/2f
				/*((float) Math.toDegrees(angle))*/)
		);
		myCollisionID = (int) Math.pow(2, this.myNumber+1);
		
		myPS.getBody().getShapeList().m_filter.set(new FilterData());
		myPS.getBody().getShapeList().m_filter.categoryBits=myCollisionID;		
		myPG.getBody().getShapeList().m_filter.categoryBits=myCollisionID;
		
		myPG.registerInputProcessor(new TapProcessor(myGCS.getMTApplication()));
		
		/*float angle2 = (float) (myPS.getBody().getAngle()+ Math.toRadians(90));
		Vec2 newPos = new Vec2();
		Vec2 diff = new Vec2();
		diff = myPG.getBody().getPosition().sub(myPS.getBody().getPosition());
		newPos.x+=myPG.getBody().getPosition().x+Math.cos(angle2)*diff.length();
		newPos.y+=myPG.getBody().getPosition().y+Math.sin(angle2)*diff.length();
		
		myPS.getBody().setXForm(newPos,myPS.getBody().getAngle());*/
		
		
		myPG.addGestureListener(TapProcessor.class, new IGestureEventListener(){

			@Override
			public boolean processGestureEvent(MTGestureEvent arg0) {
				TapEvent te = (TapEvent) arg0;
				if(te!=null){
					//myPG.setPositionGlobal(new Vector3D(myPG.getCenterPointGlobal().x+1,myPG.getCenterPointGlobal().y+1));
					//myPG.getBody().getPosition();
					//myPS.getBody().m_xf.position=new Vec2(myPS.getBody().m_xf.position.x+1,myPS.getBody().m_xf.position.y+1);
					//myPS.getBody().
					//System.out.println("current PS Pos: "+myPS.getBody().getPosition().toString());
					//System.out.println("order Pos: "+myPG.getBody().getPosition().toString());
					float angle = (float)myPS.getBody().getAngle()+Math.PI/2f/*(float) (myPS.getBody().getAngle()+ Math.toRadians(90))*/;
					//angle*=-1;
					Vec2 newPos = new Vec2();
					Vec2 diff = new Vec2();
					diff = myPG.getBody().getPosition().sub(myPS.getBody().getPosition());
					//System.out.println("pG: "+myPG.getBody().getPosition().toString());
					//System.out.println("pS: "+myPS.getBody().getPosition().toString());
					//System.out.println("diff: "+diff.toString());
					//System.out.println("trigo: "+String.valueOf(Math.cos(angle))+"/"+String.valueOf(Math.sin(angle)));
					newPos.x+=myPG.getBody().getPosition().x+Math.cos(angle)*diff.length();
					newPos.y+=myPG.getBody().getPosition().y+Math.sin(angle)*diff.length();
					//System.out.println("newPos: "+newPos.toString());
					
					//myPS.getBody().setXForm(newPos,myPS.getBody().getAngle());
					myPS.getBody().setXForm(newPos, (float) (myPS.getBody().getAngle()+ Math.toRadians(-10)));
					//myPS.getBody().setXForm(myPS.getBody().getPosition(), (float) (myPS.getBody().getAngle() + Math.toRadians(10)));
					//System.out.println("new PS Pos: "+myPS.getBody().getPosition().toString());
					
				}
				return false;
			}
			
		});
		
		//System.out.println("PS"+this.myNumber+" : "+myPS.getBody().getShapeList().m_filter.categoryBits+" / "+ myPS.getBody().getShapeList().m_filter.groupIndex);
		//System.out.println("PS"+this.myNumber+" : "+myPG.getBody().getShapeList().m_filter.categoryBits+" / "+ myPG.getBody().getShapeList().m_filter.groupIndex);
		

		//myPS.rotateZGlobal(myPS.getCenterPointGlobal(), (float) Math.toDegrees(angle)+90);
	}
}
